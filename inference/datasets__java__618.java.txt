<s> 
Analyize the time complexity of the given code. Include your choice in the [choice][/choice] tag, and only include the number of the option. (e.g. [choice]1[/choice])


Given Code:
import java.util.*;

public class kingrace {
  public static void main(String[] args) {
    Scanner input = new Scanner(System.in);
    long a = input.nextLong();
    input.nextLine();
    String[] coo = input.nextLine().split(" ");
    long xcoin = Long.parseLong(coo[0]);
    long ycoin = Long.parseLong(coo[1]);
    coordinates first = new coordinates(1, 1, a);
    coordinates second = new coordinates(a, a, a);
    double x = (double) Math.sqrt(Math.abs((xcoin - 1) * (xcoin - 1) + (ycoin - 1) * (ycoin - 1)));
    double y = (double) Math.sqrt(Math.abs((xcoin - a) * (xcoin - a) + (ycoin - a) * (ycoin - a)));
    long c = 0;
    long d = 0;
    if (x > y) {
      System.out.println("Black");
    } else if (x < y) {
      System.out.println("White");
    } else {
      c = first.Distance(new coordinates(xcoin, ycoin, a));
      d = second.Distance(new coordinates(xcoin, ycoin, a));
    }
    if (d != 0 && c != 0)
      if (d < c) {
        System.out.println("Black");

      } else {
        System.out.println("White");
      }

    input.close();
  }
}

class coordinates {
  private long xcoord;
  private long ycoord;
  private long dim;

  public coordinates(long x, long y, long dimensions) {
    xcoord = x;
    ycoord = y;
    dim = dimensions;
  }

  public void setCoordinates(long x, long y) {
    xcoord = x;
    ycoord = y;
  }

  public long Distance(coordinates num) {
    long distance = 0;

    while ((this.xcoord != num.xcoord || this.ycoord != num.ycoord)) {

      if (num.xcoord - this.xcoord == 1 && num.ycoord == this.ycoord) {

        distance++;
        this.setCoordinates(this.xcoord + 1, this.ycoord);
      } else if (num.xcoord - this.xcoord == -1 && num.ycoord == this.ycoord) {

        distance++;
        this.setCoordinates(this.xcoord - 1, this.ycoord);
      } else if (num.xcoord - this.xcoord == 0 && num.ycoord - this.ycoord == 1) {
        distance++;
        this.setCoordinates(this.xcoord, this.ycoord + 1);
      } else if (num.xcoord - this.xcoord == 0 && num.ycoord - this.ycoord == -1) {
        distance++;
        this.setCoordinates(this.xcoord, this.ycoord - 1);
      } else if (num.xcoord - this.xcoord >= 0 && num.ycoord - this.ycoord <= 0) {

        distance++;
        this.setCoordinates(this.xcoord + 1, this.ycoord - 1);
      } else if (num.xcoord - this.xcoord >= 0 && num.ycoord - this.ycoord >= 0) {
        distance++;
        this.setCoordinates(this.xcoord + 1, this.ycoord + 1);
      } else if (num.xcoord - this.xcoord <= 0 && num.ycoord - this.ycoord <= 0) {

        distance++;
        this.setCoordinates(this.xcoord - 1, this.ycoord - 1);
      } else if (num.xcoord - this.xcoord <= 0 && num.ycoord - this.ycoord >= 0) {
        distance++;
        this.setCoordinates(this.xcoord - 1, this.ycoord + 1);
      }
    }

    return distance;
  }
}


Options:
    0. O(1)
    1. O(logn)
    2. O(n)
    3. O(nlogn)
    4. O(n^2)

Among the Options above, the time complexity of the given code is [choice]3.

The code first reads input in O(1) from the user. 
Then it calculates some mathematical operations of constant input values, which takes O(1) time. 
The number of coordinates that need to be evaluated by the `Distance` function in the `coordinates` class can be up to, but not exceeding, (2a^2) (where a is the input value). 
Except for the first call to the function, each subsequent call to the `Distance` function checks whether the current coordinates match any of the previous checked coordinates. If yes, it simply increments the distance count. If not, it enters a loop where it checks whether the current coordinate matches one of the eight possible directions. If yes, it moves to the corresponding coordinate and checks again. The loop ends when the current coordinate matches either of the evaluated coordinates. In the worst case, the loop will be needed for all the unvisited coordinates, which can be up to 2a^2 coordinates, resulting in a total time complexity of O(2a^2). 
However, if there are already some checked coordinates in the neighborhood, the loop may terminate early, in which case the time complexity would be lower.</s>