<s> 
Analyize the time complexity of the given code. Include your choice in the [choice][/choice] tag, and only include the number of the option. (e.g. [choice]1[/choice])


Given Code:
import java.io.*;
import java.math.*;
import java.util.*;

public class bhaa {

  InputStream is;
  PrintWriter o;

  boolean chpr(int n) {
    if (n == 1) {
      return true;
    }
    if (n == 2) {
      return true;
    }
    if (n == 3) {
      return true;
    }
    if (n % 2 == 0) {
      return false;
    }
    if (n % 3 == 0) {
      return false;
    }

    int w = 2;
    int i = 5;
    while (i * i <= n) {
      if (n % i == 0) {
        return false;
      }
      i += w;
      w = 6 - w;
    }
    return true;
  }

  void solve() {

    int n = ni();
    int k = ni();
    int rr = 2 * n;
    int gr = 5 * n;
    int br = 8 * n;
    o.println((long) (Math.ceil(rr * 1.0 / k) + Math.ceil(gr * 1.0 / k) + Math.ceil(br * 1.0 / k)));
  }

  public static void main(String[] args) {
    new bhaa().run();
  }

  void run() {
    is = System.in;
    o = new PrintWriter(System.out);
    solve();
    o.flush();
  }

  byte input[] = new byte[1024];
  int len = 0, ptr = 0;

  int readByte() {
    if (ptr >= len) {
      ptr = 0;
      try {
        len = is.read(input);
      } catch (IOException e) {
        throw new InputMismatchException();
      }
      if (len <= 0) {
        return -1;
      }
    }
    return input[ptr++];
  }

  boolean isSpaceChar(int c) {
    return !(c >= 33 && c <= 126);
  }

  int skip() {
    int b = readByte();
    while (b != -1 && isSpaceChar(b)) {
      b = readByte();
    }
    return b;
  }

  char nc() {
    return (char) skip();
  }

  String ns() {
    int b = skip();
    StringBuilder sb = new StringBuilder();
    while (!isSpaceChar(b)) {
      sb.appendCodePoint(b);
      b = readByte();
    }
    return sb.toString();
  }

  String nLine() {
    int b = skip();
    StringBuilder sb = new StringBuilder();
    while (!(isSpaceChar(b) && b != ' ')) {
      sb.appendCodePoint(b);
      b = readByte();
    }
    return sb.toString();
  }

  int ni() {
    int n = 0, b = readByte();
    boolean minus = false;
    while (b != -1 && !((b >= '0' && b <= '9') || b == '-')) {
      b = readByte();
    }
    if (b == '-') {
      minus = true;
      b = readByte();
    }
    if (b == -1) {
      return -1;
    }
    while (b >= '0' && b <= '9') {
      n = n * 10 + (b - '0');
      b = readByte();
    }
    return minus ? -n : n;
  }

  long nl() {
    long n = 0L;
    int b = readByte();
    boolean minus = false;
    while (b != -1 && !((b >= '0' && b <= '9') || b == '-')) {
      b = readByte();
    }
    if (b == '-') {
      minus = true;
      b = readByte();
    }
    while (b >= '0' && b <= '9') {
      n = n * 10 + (b - '0');
      b = readByte();
    }
    return minus ? -n : n;
  }

  double nd() {
    return Double.parseDouble(ns());
  }

  float nf() {
    return Float.parseFloat(ns());
  }

  int[] nia(int n) {
    int a[] = new int[n];
    for (int i = 0; i < n; i++) {
      a[i] = ni();
    }
    return a;
  }

  long[] nla(int n) {
    long a[] = new long[n];
    for (int i = 0; i < n; i++) {
      a[i] = nl();
    }
    return a;
  }

  int[][] nim(int n) {
    int mat[][] = new int[n][n];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        mat[i][j] = ni();
      }
    }
    return mat;
  }

  long[][] nlm(int n) {
    long mat[][] = new long[n][n];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        mat[i][j] = nl();
      }
    }
    return mat;
  }

  char[] ns(int n) {
    char c[] = new char[n];
    int i, b = skip();
    for (i = 0; i < n; i++) {
      if (isSpaceChar(b)) {
        break;
      }
      c[i] = (char) b;
      b = readByte();
    }
    return i == n ? c : Arrays.copyOf(c, i);
  }

  void piarr(int arr[]) {
    for (int i = 0; i < arr.length; i++) {
      o.print(arr[i] + " ");
    }
    o.println();
  }

  void plarr(long arr[]) {
    for (int i = 0; i < arr.length; i++) {
      o.print(arr[i] + " ");
    }
    o.println();
  }

  void pimat(int mat[][]) {
    for (int i = 0; i < mat.length; i++) {
      for (int j = 0; j < mat[0].length; j++) {
        o.print(mat[i][j]);
      }
      o.println();
    }
  }

  void plmat(long mat[][]) {
    for (int i = 0; i < mat.length; i++) {
      for (int j = 0; j < mat[0].length; j++) {
        o.print(mat[i][j]);
      }
      o.println();
    }
  }
}


Options:
    0. O(1)
    1. O(logn)
    2. O(n)
    3. O(nlogn)
    4. O(n^2)

Among the Options above, the time complexity of the given code is [choice]3[/choice].

The code defines an integer function chpr() which accepts an integer argument n and checks whether n is prime or not. If n is an even number (2 or 4, 6 or 8) then it is not prime. If n is a multiple of 3, then it is not prime. Otherwise, the function checks whether n can be divided by any number of the range (2, (n - 1)) by using a loop. If n is not divisible by any number in this range, then it is considered prime. The time complexity of this function is O(logn) since it is using a loop only n-1 times (n is the highest number to be checked in the loop).

The main part of the program reads integers from the input stream and performs calculations based on the requirement of the problem. It calls the chpr() function multiple times to determine whether a given integer is prime or not. Therefore, the overall time complexity of the given code is the sum of the time complexities of all the function calls.

Since the number of function calls is the number of integers read from the input stream (which is less than or equal to n), the time complexity of the main part of the program is O(n).

Therefore, the overall time complexity of the given code is O(logn + n), which is approximately O(nlogn) for larger values of n.</s>