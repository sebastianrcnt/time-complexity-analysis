<s> 
Analyize the time complexity of the given code. Include your choice in the [choice][/choice] tag, and only include the number of the option. (e.g. [choice]1[/choice])


Given Code:
class Test {

  static int mergeSort(int arr[], int array_size) {

    int temp[] = new int[array_size];

    return _mergeSort(arr, temp, 0, array_size - 1);
  }

  static int _mergeSort(int arr[], int temp[], int left, int right) {

    int mid, inv_count = 0;

    if (right > left) {

      mid = (right + left) / 2;

      inv_count = _mergeSort(arr, temp, left, mid);

      inv_count += _mergeSort(arr, temp, mid + 1, right);

      inv_count += merge(arr, temp, left, mid + 1, right);
    }

    return inv_count;
  }

  static int merge(int arr[], int temp[], int left, int mid, int right) {

    int i, j, k;

    int inv_count = 0;

    i = left;

    j = mid;

    k = left;

    while ((i <= mid - 1) && (j <= right)) {

      if (arr[i] <= arr[j]) {

        temp[k++] = arr[i++];

      } else {

        temp[k++] = arr[j++];

        inv_count = inv_count + (mid - i);
      }
    }

    while (i <= mid - 1) temp[k++] = arr[i++];

    while (j <= right) temp[k++] = arr[j++];

    for (i = left; i <= right; i++) arr[i] = temp[i];

    return inv_count;
  }

  public static void main(String[] args) {

    int arr[] = new int[] {1, 20, 6, 4, 5};

    System.out.println("Number of inversions are " + mergeSort(arr, 5));
  }
}


Options:
    0. O(1)
    1. O(logn)
    2. O(n)
    3. O(nlogn)
    4. O(n^2)

Among the Options above, the time complexity of the given code is [choice]1[/choice]. The merge sort function is called recursively which divides the array into two halves and repeatedly calls mergeSort until it reaches a base case where the array size is less than or equal to 1. The mergeSort function itself takes O(logn) time to sort the array. Therefore, the overall time complexity of mergeSort is O(logn).</s>