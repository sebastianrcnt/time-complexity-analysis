<s> 
Analyize the time complexity of the given code. Include your choice in the [choice][/choice] tag, and only include the number of the option. (e.g. [choice]1[/choice])


Given Code:
import java.io.*;
import java.util.*;

public class Main {
  static class FastReader {
    BufferedReader br;
    StringTokenizer st;

    public FastReader() {
      br = new BufferedReader(new InputStreamReader(System.in));
    }

    String next() {
      while (st == null || !st.hasMoreElements()) {
        try {
          st = new StringTokenizer(br.readLine());
        } catch (IOException e) {
          e.printStackTrace();
        }
      }
      return st.nextToken();
    }

    int nextInt() {
      return Integer.parseInt(next());
    }

    long nextLong() {
      return Long.parseLong(next());
    }

    double nextDouble() {
      return Double.parseDouble(next());
    }

    float nextFloat() {
      return Float.parseFloat(next());
    }

    boolean nextBoolean() {
      return Boolean.parseBoolean(next());
    }

    String nextLine() {
      String str = "";
      try {
        str = br.readLine();
      } catch (IOException e) {
        e.printStackTrace();
      }
      return str;
    }
  }

  static long modExp(long x, long n, long mod) {
    long result = 1;
    while (n > 0) {
      if (n % 2 == 1) result = (result % mod * x % mod) % mod;
      x = (x % mod * x % mod) % mod;
      n = n / 2;
    }
    return result;
  }

  static long gcd(long a, long b) {
    if (a == 0) return b;
    return gcd(b % a, a);
  }

  public static void main(String[] args) throws IOException {
    FastReader fr = new FastReader();
    long n = fr.nextLong();
    long x = fr.nextLong();
    long y = fr.nextLong();
    long w = Long.min(x, y) - 1 + (x - Long.min(x, y)) + (y - Long.min(x, y));
    long b = n - Long.max(x, y) + (Long.max(x, y) - x) + (Long.max(x, y) - y);
    if (w <= b) System.out.println("White");
    else System.out.println("Black");
  }
}

class Pair<U, V> {
  public final U first;
  public final V second;

  private Pair(U first, V second) {
    this.first = first;
    this.second = second;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;

    if (o == null || getClass() != o.getClass()) return false;

    Pair<?, ?> pair = (Pair<?, ?>) o;

    if (!first.equals(pair.first)) return false;
    return second.equals(pair.second);
  }

  @Override
  public int hashCode() {
    return 31 * first.hashCode() + second.hashCode();
  }

  public static <U, V> Pair<U, V> of(U a, V b) {
    return new Pair<>(a, b);
  }
}

class myComp implements Comparator<Pair> {
  public int compare(Pair a, Pair b) {
    if (a.first != b.first) return ((int) a.first - (int) b.first);
    if (a.second != b.second) return ((int) a.second - (int) b.second);
    return 0;
  }
}

class BIT {
  public long[] m_array;

  public BIT(long[] dat) {
    m_array = new long[dat.length + 1];
    Arrays.fill(m_array, 0);
    for (int i = 0; i < dat.length; i++) {
      m_array[i + 1] = dat[i];
    }
    for (int i = 1; i < m_array.length; i++) {
      int j = i + (i & -i);
      if (j < m_array.length) {
        m_array[j] = m_array[j] + m_array[i];
      }
    }
  }

  public final long prefix_query(int i) {
    long result = 0;
    for (++i; i > 0; i = i - (i & -i)) {
      result = result + m_array[i];
    }
    return result;
  }

  public final long range_query(int fro, int to) {
    if (fro == 0) {
      return prefix_query(to);
    } else {
      return (prefix_query(to) - prefix_query(fro - 1));
    }
  }

  public void update(int i, long add) {
    for (++i; i < m_array.length; i = i + (i & -i)) {
      m_array[i] = m_array[i] + add;
    }
  }
}


Options:
    0. O(1)
    1. O(logn)
    2. O(n)
    3. O(nlogn)
    4. O(n^2)

Among the Options above, the time complexity of the given code is [choice]1[/choice].

Explanation:
The code given in the question has two operations, prefix_query and update. The prefix_query operation is implemented using a bit manipulation technique, which is a constant time operation i.e., O(1).
On the other hand, the update operation is performed using the same BIT data structure used for range_query operation. Since range_query is implemented as a linear time operation, by making a sequence of prefix_query and update operations, it can be shown that the total time complexity of the given code is O(logn). Hence, the time complexity of the given code is [choice]1[/choice].</s>