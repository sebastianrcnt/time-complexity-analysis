<s> 
Analyize the time complexity of the given code. Include your choice in the [choice][/choice] tag, and only include the number of the option. (e.g. [choice]1[/choice])


Given Code:
class LinkedList {

  static Node head;

  static class Node {

    int data;

    Node next, prev;

    Node(int d) {

      data = d;

      next = prev = null;
    }
  }

  void print(Node node) {

    Node temp = node;

    System.out.println("Forward Traversal using next pointer");

    while (node != null) {

      System.out.print(node.data + " ");

      temp = node;

      node = node.next;
    }

    System.out.println("\nBackward Traversal using prev pointer");

    while (temp != null) {

      System.out.print(temp.data + " ");

      temp = temp.prev;
    }
  }

  Node split(Node head) {

    Node fast = head, slow = head;

    while (fast.next != null && fast.next.next != null) {

      fast = fast.next.next;

      slow = slow.next;
    }

    Node temp = slow.next;

    slow.next = null;

    return temp;
  }

  Node mergeSort(Node node) {

    if (node == null || node.next == null) {

      return node;
    }

    Node second = split(node);

    node = mergeSort(node);

    second = mergeSort(second);

    return merge(node, second);
  }

  Node merge(Node first, Node second) {

    if (first == null) {

      return second;
    }

    if (second == null) {

      return first;
    }

    if (first.data < second.data) {

      first.next = merge(first.next, second);

      first.next.prev = first;

      first.prev = null;

      return first;

    } else {

      second.next = merge(first, second.next);

      second.next.prev = second;

      second.prev = null;

      return second;
    }
  }

  public static void main(String[] args) {

    LinkedList list = new LinkedList();

    list.head = new Node(10);

    list.head.next = new Node(30);

    list.head.next.next = new Node(3);

    list.head.next.next.next = new Node(4);

    list.head.next.next.next.next = new Node(20);

    list.head.next.next.next.next.next = new Node(5);

    Node node = null;

    node = list.mergeSort(head);

    System.out.println("Linked list after sorting :");

    list.print(node);
  }
}


Options:
    0. O(1)
    1. O(logn)
    2. O(n)
    3. O(nlogn)
    4. O(n^2)

Among the Options above, the time complexity of the given code is [choice]3[/choice].

Explanation: The `mergeSort` method of the `LinkedList` class uses the divide-and-conquer approach to sort the linked list. It keeps splitting the linked list into smaller parts until each part has a length of 1 or 2, which is the base case for the recursive algorithm. The time complexity of the splitting operation is linear in the size of the linked list, which is O(n). Since the `mergeSort` function recursively divides the linked list into two halves, the worst-case time complexity of the `mergeSort` function is O(nlogn).</s>