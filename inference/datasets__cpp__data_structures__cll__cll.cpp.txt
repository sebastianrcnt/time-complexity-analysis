<s> 
Analyize the time complexity of the given code. Include your choice in the [choice][/choice] tag, and only include the number of the option. (e.g. [choice]1[/choice])


Given Code:
/*
    A simple class for Cicular Linear Linked List
*/
#include "cll.h"
using namespace std;

/* Constructor */
cll::cll() {
    head = NULL;
    total = 0;
}

cll::~cll() { /* Desstructure, no need to fill */
}

/* Display a list. and total element */
void cll::display() {
    if (head == NULL)
        cout << "List is empty !" << endl;
    else {
        cout << "CLL list: ";
        node *current = head;
        for (int i = 0; i < total; i++) {
            cout << current->data << " -> ";
            current = current->next;
        }
        cout << head->data << endl;
        cout << "Total element: " << total << endl;
    }
}

/* List insert a new value at head in list */
void cll::insert_front(int new_data) {
    node *newNode;
    newNode = new node;
    newNode->data = new_data;
    newNode->next = NULL;
    if (head == NULL) {
        head = newNode;
        head->next = head;
    } else {
        node *current = head;
        while (current->next != head) {
            current = current->next;
        }
        newNode->next = head;
        current->next = newNode;
        head = newNode;
    }
    total++;
}

/* List insert a new value at head in list */
void cll::insert_tail(int new_data) {
    node *newNode;
    newNode = new node;
    newNode->data = new_data;
    newNode->next = NULL;
    if (head == NULL) {
        head = newNode;
        head->next = head;
    } else {
        node *current = head;
        while (current->next != head) {
            current = current->next;
        }
        current->next = newNode;
        newNode->next = head;
    }
    total++;
}

/* Get total element in list */
int cll::get_size() { return total; }

/* Return true if the requested item (sent in as an argument)
is in the list, otherwise return false */
bool cll::find_item(int item_to_find) {
    if (head == NULL) {
        cout << "List is empty !" << endl;
        return false;
    } else {
        node *current = head;
        while (current->next != head) {
            if (current->data == item_to_find)
                return true;
            current = current->next;
        }
        return false;
    }
}

/* Overloading method*/
int cll::operator*() { return head->data; }

/* Overload the pre-increment operator.
   The iterator is advanced to the next node. */
void cll::operator++() {
    if (head == NULL) {
        cout << "List is empty !" << endl;
    } else {
        node *current = head;
        while (current->next != head) {
            current = current->next;
        }
        current->next = head->next;
        head = head->next;
    }
    total--;
}


Options:
    0. O(1)
    1. O(logn)
    2. O(n)
    3. O(nlogn)
    4. O(n^2)

Among the Options above, the time complexity of the given code is [choice]3[/choice]. The reason for this is that the loop in the insert_tail function runs from 0 to n, where n is the total number of elements in the list. This means that the total number of iterations is proportional to the total number of elements in the list. The other operations, such as get_size, display, and insert_front, can be done with constant time complexity, which is why they are not included in the time complexity analysis.</s>