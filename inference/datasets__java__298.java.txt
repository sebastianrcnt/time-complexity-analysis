<s> 
Analyize the time complexity of the given code. Include your choice in the [choice][/choice] tag, and only include the number of the option. (e.g. [choice]1[/choice])


Given Code:
import java.util.Arrays;

class GFG {

  static final int MAX = 100;

  static int getMaxGold(int gold[][], int m, int n) {

    int goldTable[][] = new int[m][n];

    for (int[] rows : goldTable) Arrays.fill(rows, 0);

    for (int col = n - 1; col >= 0; col--) {

      for (int row = 0; row < m; row++) {

        int right = (col == n - 1) ? 0 : goldTable[row][col + 1];

        int right_up = (row == 0 || col == n - 1) ? 0 : goldTable[row - 1][col + 1];

        int right_down = (row == m - 1 || col == n - 1) ? 0 : goldTable[row + 1][col + 1];

        goldTable[row][col] = gold[row][col] + Math.max(right, Math.max(right_up, right_down));

        ;
      }
    }

    int res = goldTable[0][0];

    for (int i = 1; i < m; i++) res = Math.max(res, goldTable[i][0]);

    return res;
  }

  public static void main(String arg[]) {

    int gold[][] = {{1, 3, 1, 5}, {2, 2, 4, 1}, {5, 0, 2, 3}, {0, 6, 1, 2}};

    int m = 4, n = 4;

    System.out.print(getMaxGold(gold, m, n));
  }
}


Options:
    0. O(1)
    1. O(logn)
    2. O(n)
    3. O(nlogn)
    4. O(n^2)

Among the Options above, the time complexity of the given code is [choice]4[/choice], which is O(n^2). 

Here's how we arrived at this conclusion: 

1. We first loop through each cell in the grid in a bottom-up manner to calculate the maximum value at each cell. This takes O(mn) time.
2. After calculating the maximum value at each cell, we then calculate the maximum value at the row where all three adjacent cells have been processed. This takes O(mn^2) time, as we first process the lower-left cell and then have to search all the adjacent cells.
3. Finally, we have to calculate the maximum value over all rows, which takes O(n^2) time.

Thus, the time complexity is O(n^2).</s>