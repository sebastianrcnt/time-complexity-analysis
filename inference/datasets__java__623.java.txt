<s> 
Analyize the time complexity of the given code. Include your choice in the [choice][/choice] tag, and only include the number of the option. (e.g. [choice]1[/choice])


Given Code:
import java.util.ArrayList;
import java.util.Scanner;

public class TaxiDriversAndLyft {

  static class Resident {
    Integer index;
    Integer type;
    Integer requests;

    public Resident(int index, int type) {
      this.index = index;
      this.type = type;
      this.requests = 0;
    }

    @Override
    public String toString() {
      if (type == 0) {
        return "Rider at index : " + index;
      } else {
        return "Driver at index : " + index + ", Requests: " + requests;
      }
    }
  }

  static ArrayList<Resident> residents;
  static ArrayList<Integer> drivers_indexes = new ArrayList<>();

  public static void main(String[] args) {
    Scanner reader = new Scanner(System.in);
    int n = reader.nextInt();
    int m = reader.nextInt();
    int length = n + m;

    int[] coordinates = new int[length];
    int[] types = new int[length];
    residents = new ArrayList<>();
    drivers_indexes = new ArrayList<>();

    for (int i = 0; i < length; i++) {
      coordinates[i] = reader.nextInt();
    }

    for (int i = 0; i < length; i++) {
      types[i] = reader.nextInt();

      if (types[i] == 1) drivers_indexes.add(i);

      residents.add(new Resident(i, types[i]));
    }
    reader.close();

    for (int i = 0; i < length; i++) {
      Resident current = residents.get(i);
      if (current.type == 0) {
        int left = i - 1, right = i + 1;

        while (left >= 0 || right < length) {
          if (left >= 0 && residents.get(left).type == 1) {
            residents.get(left).requests++;
            break;
          } else if (right < length && residents.get(right).type == 1) {
            residents.get(right).requests++;
            break;
          }

          left--;
          right++;
        }
      }
    }

    for (int index : drivers_indexes) {
      System.out.print(residents.get(index).requests + " ");
    }
  }
}


Options:
    0. O(1)
    1. O(logn)
    2. O(n)
    3. O(nlogn)
    4. O(n^2)

Among the Options above, the time complexity of the given code is [choice]1[/choice].

Explanation:
The code uses two input arrays: coordinates (length 'n') and types (length 'n'). 
When creating new Resident object for each index, the code iterates over 'n' elements, which takes O(n) time. 
When printing the requests, it only iterates over 'm' elements, which is the number of requests. 
The code does not use any recursive or looping structure which is directly related to the input size so the time complexity is constant.
Since the code does not use any recursive or looping structure which is directly related to the input size, the time complexity is constant.</s>