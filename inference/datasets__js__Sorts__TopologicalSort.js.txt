<s> 
Analyize the time complexity of the given code. Include your choice in the [choice][/choice] tag, and only include the number of the option. (e.g. [choice]1[/choice])


Given Code:
export function TopologicalSorter() {
  const graph = {}
  let isVisitedNode
  let finishTimeCount
  let finishingTimeList
  let nextNode

  this.addOrder = function (nodeA, nodeB) {
    nodeA = String(nodeA)
    nodeB = String(nodeB)
    graph[nodeA] = graph[nodeA] || []
    graph[nodeA].push(nodeB)
  }

  this.sortAndGetOrderedItems = function () {
    isVisitedNode = Object.create(null)
    finishTimeCount = 0
    finishingTimeList = []

    for (const node in graph) {
      if (
        Object.prototype.hasOwnProperty.call(graph, node) &&
        !isVisitedNode[node]
      ) {
        dfsTraverse(node)
      }
    }

    finishingTimeList.sort(function (item1, item2) {
      return item1.finishTime > item2.finishTime ? -1 : 1
    })

    return finishingTimeList.map(function (value) {
      return value.node
    })
  }

  function dfsTraverse(node) {
    isVisitedNode[node] = true
    if (graph[node]) {
      for (let i = 0; i < graph[node].length; i++) {
        nextNode = graph[node][i]
        if (isVisitedNode[nextNode]) continue
        dfsTraverse(nextNode)
      }
    }

    finishingTimeList.push({
      node,
      finishTime: ++finishTimeCount
    })
  }
}

/* TEST */
// const topoSorter = new TopologicalSorter()
// topoSorter.addOrder(5, 2)
// topoSorter.addOrder(5, 0)
// topoSorter.addOrder(4, 0)
// topoSorter.addOrder(4, 1)
// topoSorter.addOrder(2, 3)
// topoSorter.addOrder(3, 1)
// topoSorter.sortAndGetOrderedItems()


Options:
    0. O(1)
    1. O(logn)
    2. O(n)
    3. O(nlogn)
    4. O(n^2)

Among the Options above, the time complexity of the given code is [choice]3[/choice], O(n). This is because the code has two primary functions: `addOrder` and `sortAndGetOrderedItems`. 

The `addOrder` function iterates through the list of neighbours of the given node, but each iteration has an average time complexity of O(1), as it just accesses one element in the `graph` object. Thus, adding a maximum of n edges (nodes and edges with a mutual connection) to the `graph` results in n iterations. 

The `sortAndGetOrderedItems` function, on the other hand, has a recursive `dfsTraverse` function that iterates through each node and its neighbours until there are no more unvisited nodes left. The `dfsTraverse` function visits each node at most once, so each iteration takes 1 unit of time on average. Since the number of nodes is n, and the `dfsTraverse` visits each node and its neighbours exactly once, this function's time complexity is O(n). 

Therefore, the overall time complexity of the given code is O(n) (10 iterations and 10 recursions).</s>