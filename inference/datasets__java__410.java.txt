<s> 
Analyize the time complexity of the given code. Include your choice in the [choice][/choice] tag, and only include the number of the option. (e.g. [choice]1[/choice])


Given Code:
class GfG {

  static class node {

    int data;

    node left, right;
  }

  static int updatetree(node root) {

    if (root == null) return 0;

    if (root.left == null && root.right == null) return root.data;

    int leftsum = updatetree(root.left);

    int rightsum = updatetree(root.right);

    root.data += leftsum;

    return root.data + rightsum;
  }

  static void inorder(node node) {

    if (node == null) return;

    inorder(node.left);

    System.out.print(node.data + " ");

    inorder(node.right);
  }

  static node newNode(int data) {

    node node = new node();

    node.data = data;

    node.left = null;

    node.right = null;

    return (node);
  }

  public static void main(String[] args) {

    node root = newNode(1);

    root.left = newNode(2);

    root.right = newNode(3);

    root.left.left = newNode(4);

    root.left.right = newNode(5);

    root.right.right = newNode(6);

    updatetree(root);

    System.out.println("Inorder traversal of the modified tree is");

    inorder(root);
  }
}


Options:
    0. O(1)
    1. O(logn)
    2. O(n)
    3. O(nlogn)
    4. O(n^2)

Among the Options above, the time complexity of the given code is [choice]3[/choice]. 

Explanation:
The main reason for this is that the function updatetree() takes an additional time complexity of O(n) as it needs to traverse the tree again to update the node values. The inorder() function is called twice with O(n) time complexity each, leading to an overall time complexity of O(n)+O(n) = O(n).</s>