<s> 
Analyize the time complexity of the given code. Include your choice in the [choice][/choice] tag, and only include the number of the option. (e.g. [choice]1[/choice])


Given Code:
import java.util.Arrays;

class GFG {

  static int MAX = 100;

  static int dp[][] = new int[MAX][MAX];

  static int countRemovals(int a[], int i, int j, int k) {

    if (i >= j) return 0;
    else if ((a[j] - a[i]) <= k) return 0;
    else if (dp[i][j] != -1) return dp[i][j];
    else if ((a[j] - a[i]) > k) {

      dp[i][j] = 1 + Math.min(countRemovals(a, i + 1, j, k), countRemovals(a, i, j - 1, k));
    }

    return dp[i][j];
  }

  static int removals(int a[], int n, int k) {

    Arrays.sort(a);

    for (int[] rows : dp) Arrays.fill(rows, -1);

    if (n == 1) return 0;
    else return countRemovals(a, 0, n - 1, k);
  }

  public static void main(String[] args) {

    int a[] = {1, 3, 4, 9, 10, 11, 12, 17, 20};

    int n = a.length;

    int k = 4;

    System.out.print(removals(a, n, k));
  }
}


Options:
    0. O(1)
    1. O(logn)
    2. O(n)
    3. O(nlogn)
    4. O(n^2)

Among the Options above, the time complexity of the given code is [choice]1[/choice].

Explanation:

The time complexity of the given code is O(logn) because the given function `countRemovals()` is invoked recursively and the parameters of the function are sorted, which will reduce the number of recursive calls. The function returns the minimum of the recursive calls made for `i+1`th and `j-1`th indices of the array.

The function `removals()` is recursively called by using a binary search algorithm on the sorted array which has a time complexity of O(logn). Since the function is recursively called, the overall time complexity of the entire program is O(logn).</s>