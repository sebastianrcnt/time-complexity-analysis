<s> 
Analyize the time complexity of the given code. Include your choice in the [choice][/choice] tag, and only include the number of the option. (e.g. [choice]1[/choice])


Given Code:
import java.util.*;

class Binary {

  public static int f(int x) {

    return (x * x - 10 * x - 20);
  }

  public static int findFirstPositive() {

    if (f(0) > 0) return 0;

    int i = 1;

    while (f(i) <= 0) i = i * 2;

    return binarySearch(i / 2, i);
  }

  public static int binarySearch(int low, int high) {

    if (high >= low) {

      int mid = low + (high - low) / 2;

      if (f(mid) > 0 && (mid == low || f(mid - 1) <= 0)) return mid;

      if (f(mid) <= 0) return binarySearch((mid + 1), high);
      else return binarySearch(low, (mid - 1));
    }

    return -1;
  }

  public static void main(String[] args) {

    System.out.print("The value n where f() " + "becomes positive first is " + findFirstPositive());
  }
}


Options:
    0. O(1)
    1. O(logn)
    2. O(n)
    3. O(nlogn)
    4. O(n^2)

Among the Options above, the time complexity of the given code is [choice]3.O(n)

Explanation:

The time complexity of f(int x) function is O(1) because no matter how large the input value x is, it takes the same amount of time to calculate the result.

The function findFirstPositive takes log(n) time in the worst case. It uses a binary search algorithm to find the binary value where f(binary value) becomes positive for the first time.
The binarySearch function returns the position of the binary value in the sorted array of values from 0 to n-1.

After that, the while loop runs n times because the value of i keeps doubling until it reaches a positive integer.
So, the overall time complexity of the given code is O(n) where n is the maximum value of the input integer after which f(n) becomes positive for the first time.</s>