<s> 
Analyize the time complexity of the given code. Include your choice in the [choice][/choice] tag, and only include the number of the option. (e.g. [choice]1[/choice])


Given Code:
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.StringTokenizer;

public class B {
  static ArrayList<Integer>[] adj;
  static int[] num;

  static int dfs(int u, int p) {
    int cnt = 0;
    for (int v : adj[u]) {
      if (v != p) cnt += dfs(v, u);
    }
    if (adj[u].size() == 1 && u != 0 || u == 0 && adj[0].size() == 0) cnt++;
    num[cnt]++;
    return cnt;
  }

  public static void main(String[] args) throws NumberFormatException, IOException {
    Scanner sc = new Scanner();
    PrintWriter out = new PrintWriter(System.out);
    int n = sc.nextInt();
    adj = new ArrayList[n];
    for (int i = 0; i < adj.length; ++i) {
      adj[i] = new ArrayList<>();
    }
    for (int i = 1; i < n; ++i) {
      int p = sc.nextInt() - 1;
      adj[p].add(i);
      adj[i].add(p);
    }
    num = new int[n + 1];
    dfs(0, -1);
    for (int i = 1; i < num.length; ++i) {
      num[i] += num[i - 1];
    }
    int cur = 1;
    for (int i = 0; i < num.length; ++i) {
      while (cur <= num[i]) {
        out.print(i + " ");
        ++cur;
      }
    }
    out.close();
  }

  static class Scanner {
    BufferedReader br;
    StringTokenizer st;

    public Scanner() {
      br = new BufferedReader(new InputStreamReader(System.in));
    }

    public String next() throws IOException {
      while (st == null || !st.hasMoreTokens()) {
        st = new StringTokenizer(br.readLine());
      }
      return st.nextToken();
    }

    public int nextInt() throws NumberFormatException, IOException {
      return Integer.parseInt(next());
    }
  }
}


Options:
    0. O(1)
    1. O(logn)
    2. O(n)
    3. O(nlogn)
    4. O(n^2)

Among the Options above, the time complexity of the given code is [choice]3[/choice]. 

The reason for this choice is that in the main function, we are iterating through the adjacency list of each vertex once, which is n times. At the beginning, we traverse the adjacency list using a for loop, which takes O(n) time. After this, we use another loop, which takes O(n) time, to iterate through the adjacency list to append the number of nodes with depth equal to the current vertex to the num array.</s>